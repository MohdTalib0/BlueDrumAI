/**
 * Vault PDF Generator
 * Generates lawyer-ready PDF exports of vault entries with metadata and timeline
 */

import PDFDocument from 'pdfkit'
import { supabaseAdmin } from '../supabase'

interface VaultEntry {
  id: string
  type: 'photo' | 'document' | 'ticket' | 'receipt' | 'other'
  file_url: string
  description?: string
  metadata?: {
    filename: string
    mimeType: string
    size: number
    uploadedAt: string
    location?: { lat: number; lng: number }
    dateTaken?: string
  }
  created_at: string
}

interface VaultPDFData {
  userId: string
  userEmail: string
  entries: VaultEntry[]
  generatedAt: string
}

/**
 * Format file size in human-readable format
 */
function formatFileSize(bytes: number): string {
  if (bytes === 0) return '0 Bytes'
  const k = 1024
  const sizes = ['Bytes', 'KB', 'MB', 'GB']
  const i = Math.floor(Math.log(bytes) / Math.log(k))
  return Math.round((bytes / Math.pow(k, i)) * 100) / 100 + ' ' + sizes[i]
}

/**
 * Format currency (for receipts/tickets)
 */
function formatCurrency(amount: number): string {
  return `â‚¹${amount.toLocaleString('en-IN', { minimumFractionDigits: 2, maximumFractionDigits: 2 })}`
}

/**
 * Format date for display
 */
function formatDate(dateString: string): string {
  const date = new Date(dateString)
  return date.toLocaleDateString('en-IN', {
    year: 'numeric',
    month: 'long',
    day: 'numeric',
    hour: '2-digit',
    minute: '2-digit',
  })
}

/**
 * Generate PDF for vault entries
 */
export async function generateVaultPDF(data: VaultPDFData): Promise<Buffer> {
  return new Promise((resolve, reject) => {
    try {
      const doc = new PDFDocument({
        size: 'A4',
        margins: { top: 50, bottom: 50, left: 60, right: 60 },
        info: {
          Title: 'Evidence Vault Export',
          Author: 'Blue Drum AI',
          Subject: 'Legal Evidence Documentation',
          Creator: 'Blue Drum AI - Evidence-based legal vigilance',
        },
      })

      const buffers: Buffer[] = []
      doc.on('data', buffers.push.bind(buffers))
      doc.on('end', () => {
        const pdfBuffer = Buffer.concat(buffers)
        resolve(pdfBuffer)
      })
      doc.on('error', reject)

      // Header
      doc.fontSize(20).font('Helvetica-Bold').fillColor('#1e40af').text('EVIDENCE VAULT EXPORT', { align: 'center' })
      doc.moveDown(0.5)
      doc.fontSize(10).font('Helvetica').fillColor('#666666').text('Generated by Blue Drum AI - Evidence-based legal vigilance', { align: 'center' })
      doc.moveDown(1)

      // User Information
      doc.fontSize(12).font('Helvetica-Bold').fillColor('#1e3a8a').text('User Information', 60, doc.y)
      doc.moveDown(0.3)
      doc.fontSize(10).font('Helvetica').fillColor('#374151')
      doc.text(`Email: ${data.userEmail}`, { indent: 20 })
      doc.text(`Export Date: ${formatDate(data.generatedAt)}`, { indent: 20 })
      doc.text(`Total Entries: ${data.entries.length}`, { indent: 20 })
      doc.moveDown(1)

      // Summary Statistics
      const typeCounts = data.entries.reduce((acc, entry) => {
        acc[entry.type] = (acc[entry.type] || 0) + 1
        return acc
      }, {} as Record<string, number>)

      doc.fontSize(12).font('Helvetica-Bold').fillColor('#1e3a8a').text('Summary', 60, doc.y)
      doc.moveDown(0.3)
      doc.fontSize(10).font('Helvetica').fillColor('#374151')
      Object.entries(typeCounts).forEach(([type, count]) => {
        doc.text(`${type.charAt(0).toUpperCase() + type.slice(1)}: ${count}`, { indent: 20 })
      })
      doc.moveDown(1.5)

      // Timeline of Entries
      const sortedEntries = [...data.entries].sort((a, b) => new Date(a.created_at).getTime() - new Date(b.created_at).getTime())

      doc.fontSize(14).font('Helvetica-Bold').fillColor('#1e40af').text('EVIDENCE TIMELINE', { align: 'center' })
      doc.moveDown(0.5)

      sortedEntries.forEach((entry, index) => {
        // Check if we need a new page
        if (doc.y > 700) {
          doc.addPage()
        }

        // Entry Header
        const entryDate = formatDate(entry.created_at)
        doc.fontSize(11).font('Helvetica-Bold').fillColor('#1e3a8a')
        doc.text(`Entry ${index + 1}: ${entry.type.charAt(0).toUpperCase() + entry.type.slice(1)}`, 60, doc.y)
        doc.moveDown(0.2)

        // Entry Details Box
        const boxY = doc.y
        doc.rect(60, boxY, 495, 80).stroke('#e5e7eb')
        doc.fontSize(9).font('Helvetica').fillColor('#374151')

        let detailY = boxY + 10
        doc.text(`Date Uploaded: ${entryDate}`, 70, detailY)
        detailY += 15

        if (entry.metadata?.filename) {
          doc.text(`Filename: ${entry.metadata.filename}`, 70, detailY)
          detailY += 15
        }

        if (entry.metadata?.size) {
          doc.text(`File Size: ${formatFileSize(entry.metadata.size)}`, 70, detailY)
          detailY += 15
        }

        if (entry.metadata?.dateTaken) {
          doc.text(`Date Taken: ${formatDate(entry.metadata.dateTaken)}`, 70, detailY)
          detailY += 15
        }

        if (entry.metadata?.location) {
          doc.text(
            `Location: ${entry.metadata.location.lat.toFixed(6)}, ${entry.metadata.location.lng.toFixed(6)}`,
            70,
            detailY
          )
          detailY += 15
        }

        if (entry.description) {
          doc.text(`Description: ${entry.description}`, 70, detailY)
        }

        doc.y = boxY + 90
        doc.moveDown(0.5)

        // File URL (for reference)
        doc.fontSize(8).font('Helvetica-Oblique').fillColor('#9ca3af')
        doc.text(`File Reference: ${entry.file_url}`, 70, doc.y, { width: 475 })
        doc.moveDown(0.8)
      })

      // Footer on each page
      const pageCount = doc.bufferedPageRange().count
      for (let i = 0; i < pageCount; i++) {
        doc.switchToPage(i)
        doc.fontSize(7).font('Helvetica-Oblique').fillColor('#9ca3af')
        doc.text(
          `Page ${i + 1} of ${pageCount} | Generated by Blue Drum AI - Evidence-based legal vigilance`,
          60,
          doc.page.height - 30,
          { align: 'center', width: 495 }
        )
        doc.text(`Document ID: ${data.userId}-${Date.now()}`, 60, doc.page.height - 20, { align: 'center', width: 495 })
      }

      doc.end()
    } catch (error) {
      reject(error)
    }
  })
}

/**
 * Fetch vault entries for a user
 */
export async function getVaultEntriesForPDF(userId: string): Promise<VaultEntry[]> {
  const { data, error } = await supabaseAdmin
    .from('vault_entries')
    .select('*')
    .eq('user_id', userId)
    .order('created_at', { ascending: true })

  if (error) {
    throw new Error(`Failed to fetch vault entries: ${error.message}`)
  }

  return (data || []) as VaultEntry[]
}

